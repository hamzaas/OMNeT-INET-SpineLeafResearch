---
layout: default
title: SendScript.py
parent: Python Scripts
grand_parent: Code
nav_order: 3
---

# SendScript.py

***

 - `SendScript.py`: This script is responsible for generating the traffic in the simulation.
There are several parameters used in this script, but these will be discussed in the `script`
section. The traffic is generated by creating a new `ini` file. Think of the `ini` file
as the main component of the simulation, all main configurations are specified in this file.
The input of this script is the command line input. The output is a `ini_generated.ini`, the
newly generated `ini` file, and `size_feq.txt`, traffic frequency data to be used post simulation.

- INET documentation for traffic generation can be found in the [TCP Session App](https://inet.omnetpp.org/docs/users-guide/ch-apps.html#tcpsessionapp)

- This script is perhaps one of the most import in the simulation as it generates the traffic.

- This traffic generation is done in two parts. First, generating source and target address.
Second, generating the actual traffic.

- Moreover, there are several parameters in this generator.

***

1. `APPLICATION_PERCENTAGE`: Used to determine the number of applications per host (if not specified).
2. `INTER_INTRA_PERCENTAGE`: Used to determined the percentage of inter rack vs intra rack communications.
3. `MICE_ELEPHANT_PERCENTAGE`: Used to determine the percentage of mice vs elephant flows.
4. `ON_OFF_PERCENTAGE`: Used to determine the percentage of on vs off periods in the applications
5. `MAX_SECONDS`: The number of seconds that traffic should be generated.
6. `MICE_MIN`: The minimum value of the mice flow.
7. `MICE_MAX`: The maximum value of the mice flow.
8. `ELEPHANT_MIN`: The minimum value of the elephant flow.
9. `ELEPHANT_MAX`: The maximum value of the elephant flow.

***

### Generating Connect Addresses

- The first part of this script is to decide which host each application can communicate with.
This can either happen inter rack or intra rack.

- This is done by iterating over all possible applications, deciding if they will communicate
inter rack or intra rack and then generating a random host for the app to connect with.

- The code for this section can be found below.

```python
Iteration from 0 : NUM_LEAVES
for i in range(NUM_LEAFS):

   # Iterating from 0 : HOSTS_PER_LEAF of LEAF
   for j in range(NUM_HOSTS_PER_LEAF[i]):

       rand_num = int(random.random() * INTER_INTRA_PERCENTAGE)

       if rand_num == 0 and NUM_HOSTS_PER_LEAF[i] > 1:
           # Iterating from 1 : NUM_APPLICATIONS on host
           for k in range(1, NUM_APPLICATIONS):

               rand_host = int(random.random() * NUM_HOSTS_PER_LEAF[i])
               while rand_host == j:
                   rand_host = int(random.random() * NUM_HOSTS_PER_LEAF[i])

               current_app = "**.leaf[" + str(i) + "].H[" + str(j) + "].app[" + str(k) + "]"
               connect_address = "leaf[" + str(i) + "].H[" + str(rand_host) + "]"
               write_connect_address(new_ini_file, current_app, connect_address)
               app_list.append(current_app)

       else:
           for k in range(1, NUM_APPLICATIONS):
               rand_leaf = int(random.random() * NUM_LEAFS)
               while rand_leaf == i:
                   rand_leaf = int(random.random() * NUM_LEAFS)

               rand_host = int(random.random() * NUM_HOSTS_PER_LEAF[rand_leaf])
               current_app = "**.leaf[" + str(i) + "].H[" + str(j) + "].app[" + str(k) + "]"
               connect_address = "leaf[" + str(rand_leaf) + "].H[" + str(rand_host) + "]"
               write_connect_address(new_ini_file, current_app, connect_address)
               app_list.append(current_app)

```

***

### Generating Traffic

 - The actual traffic generation is implemented after the connect address are determined.

 - The algorithm works by determining the traffic for [0, MAX_SECONDS] for each application in that order.
 In more detail, each applicaiton gets its full traffic at once before moving onto the next applicaiton.

 - This process is done by determining if the current traffic `t` at second `s` is mice or elephant and then
 appending this traffic to a string as a tuple `(s t)`.

 -The code that does this can be seen below.

 ```python
 for app in app_list:
     send_script_string = ""
     for second in range(1, MAX_SECONDS):
         on_off = int(random.random() * ON_OFF_PERCENTAGE)
         if on_off == 0:
             rand_flow = int(random.random() * MICE_ELEPHANT_PERCENTAGE)

             # Mice Flow
             if rand_flow == 0:
                 # Focusing more data on MICE_MIN 60% chance
                 rand_mice_min = int(random.random() * 100)
                 temp_max = MICE_MAX

                 if rand_mice_min <= 80:
                     temp_max = MICE_MIN + (MICE_MAX - MICE_MIN) * 0.03
                 else:
                     temp_max = MICE_MIN + (MICE_MAX - MICE_MIN) * random.random()

                 rand_size = int((random.random() * (temp_max - MICE_MIN)) + MICE_MIN)
                 send_script_string = send_script_string + " " + str(second) + " " + str(rand_size) + ";"
                 writeToMap(size_map, rand_size)

             # Elephant Flow
             else:
                 rand_ele_distro = int(random.random() * 100)
                 temp_min = ELEPHANT_MIN

                 if rand_ele_distro <= 40:
                     temp_min = ELEPHANT_MIN + int((ELEPHANT_MAX - ELEPHANT_MIN) * (random.random()))
                 elif 60 < rand_ele_distro < 100:
                     temp_min = ELEPHANT_MIN + int((ELEPHANT_MAX - ELEPHANT_MIN) * 0.96)

                 rand_size = int((random.random() * (ELEPHANT_MAX - temp_min)) + temp_min)
                 send_script_string = send_script_string + " " + str(second) + " " + str(rand_size) + ";"
                 writeToMap(size_map, rand_size)

     write_send_script(new_ini_file, send_script_string.strip(), app)

 ```
