//
// Generated file, do not edit! Created by nedtool 5.6 from inet/routing/ospfv3/Ospfv3Packet.msg.
//

#ifndef __INET__OSPFV3_OSPFV3PACKET_M_H
#define __INET__OSPFV3_OSPFV3PACKET_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0506
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// dll export symbol
#ifndef INET_API
#  if defined(INET_EXPORT)
#    define INET_API  OPP_DLLEXPORT
#  elif defined(INET_IMPORT)
#    define INET_API  OPP_DLLIMPORT
#  else
#    define INET_API
#  endif
#endif


namespace inet {
namespace ospfv3 {

class Ospfv3Packet;
struct Ospfv3Options;
class Ospfv3HelloPacket;
class Ospfv3LsaHeader;
class Ospfv3Lsa;
struct Ospfv3LsaPrefixMetric;
struct Ospfv3LsaPrefix0;
struct Ospfv3RouterLsaBody;
class Ospfv3RouterLsa;
class Ospfv3NetworkLsa;
class Ospfv3InterAreaPrefixLsa;
class Ospfv3InterAreaRouterLsa;
class Ospfv3AsExternalLsa;
class Ospfv3NssaLsa;
class Ospfv3LinkLsa;
class Ospfv3IntraAreaPrefixLsa;
struct Ospfv3DdOptions;
class Ospfv3DatabaseDescriptionPacket;
struct Ospfv3LsRequest;
class Ospfv3LinkStateRequestPacket;
class Ospfv3LinkStateUpdatePacket;
class Ospfv3LinkStateAcknowledgementPacket;
} // namespace ospfv3
} // namespace inet

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/common/packet/chunk/Chunk_m.h" // import inet.common.packet.chunk.Chunk

#include "inet/networklayer/common/L3Address_m.h" // import inet.networklayer.common.L3Address

#include "inet/networklayer/contract/ipv4/Ipv4Address_m.h" // import inet.networklayer.contract.ipv4.Ipv4Address

#include "inet/networklayer/contract/ipv6/Ipv6Address_m.h" // import inet.networklayer.contract.ipv6.Ipv6Address

#include "inet/routing/ospf_common/OspfPacketBase_m.h" // import inet.routing.ospf_common.OspfPacketBase


namespace inet {
namespace ospfv3 {

// cplusplus {{
using namespace ospf;
// }}

/**
 * Class generated from <tt>inet/routing/ospfv3/Ospfv3Packet.msg:17</tt> by nedtool.
 * <pre>
 * //Common OSPFv3 packet header - this header is present in every OSPFv3 packet
 * class Ospfv3Packet extends ospf::OspfPacketBase
 * {
 *     chunkLength = B(16);
 *     version = 3;
 *     int8_t instanceID;
 *     uint8_t reserved = 0;
 * 
 *     // RFC 5340 A.3.1.  The OSPF Packet Header: Checksum:
 *     //   OSPF uses the standard checksum calculation for IPv6 applications:
 *     //   The 16-bit one's complement of the one's complement sum of the
 *     //   entire contents of the packet, starting with the OSPF packet
 *     //   header, and prepending a "pseudo-header" of IPv6 header fields, as
 *     //   specified in Section 8.1 of [IPV6].  The "Upper-Layer Packet
 *     //   Length" in the pseudo-header is set to the value of the OSPF
 *     //   packet header's length field.  The Next Header value used in the
 *     //   pseudo-header is 89.  If the packet's length is not an integral
 *     //   number of 16-bit words, the packet is padded with a byte of zero
 *     //   before checksumming.  Before computing the checksum, the checksum
 *     //   field in the OSPF packet header is set to 0.
 * }
 * </pre>
 */
class INET_API Ospfv3Packet : public ::inet::ospf::OspfPacketBase
{
  protected:
    int8_t instanceID = 0;
    uint8_t reserved = 0;

  private:
    void copy(const Ospfv3Packet& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv3Packet&);

  public:
    Ospfv3Packet();
    Ospfv3Packet(const Ospfv3Packet& other);
    virtual ~Ospfv3Packet();
    Ospfv3Packet& operator=(const Ospfv3Packet& other);
    virtual Ospfv3Packet *dup() const override {return new Ospfv3Packet(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int8_t getInstanceID() const;
    virtual void setInstanceID(int8_t instanceID);
    virtual uint8_t getReserved() const;
    virtual void setReserved(uint8_t reserved);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv3Packet& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv3Packet& obj) {obj.parsimUnpack(b);}

/**
 * Struct generated from inet/routing/ospfv3/Ospfv3Packet.msg:39 by nedtool.
 */
struct INET_API Ospfv3Options
{
    Ospfv3Options();
    uint16_t reserved;
    bool reservedOne;
    bool reservedTwo;
    bool dcBit;
    bool rBit;
    bool nBit;
    bool xBit;
    bool eBit;
    bool v6Bit;
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const Ospfv3Options& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, Ospfv3Options& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv3Options& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv3Options& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>inet/routing/ospfv3/Ospfv3Packet.msg:55</tt> by nedtool.
 * <pre>
 * //
 * //  OSPFv3 hello packet
 * //
 * class Ospfv3HelloPacket extends Ospfv3Packet
 * {
 *     type = ospf::HELLO_PACKET;
 *     uint32_t interfaceID;                   // 32 bits
 *     char routerPriority;                    //  8 bits
 *     Ospfv3Options options;                  // 24 bits
 *     uint16_t helloInterval;                 // [sec] 16 bits
 *     uint16_t deadInterval;                  // [sec] 16 bits //TODO rename to routerDeadInterval
 *     Ipv4Address designatedRouterID;         // 32 bits
 *     Ipv4Address backupDesignatedRouterID;   // 32 bits
 *     Ipv4Address neighborID[];               // N*32 bits
 * }
 * 
 * //
 * // LSAs
 * //
 * //struct OSPFv3LSAType
 * //{
 * //    bool uBit;    //controls action the router should take when it recieves unknown LSA Function Code
 * //    bool s1Bit;
 * //    bool s2Bit;
 * //    uint16_t lsaFunctionCode;
 * //}
 * </pre>
 */
class INET_API Ospfv3HelloPacket : public ::inet::ospfv3::Ospfv3Packet
{
  protected:
    uint32_t interfaceID = 0;
    char routerPriority = 0;
    Ospfv3Options options;
    uint16_t helloInterval = 0;
    uint16_t deadInterval = 0;
    Ipv4Address designatedRouterID;
    Ipv4Address backupDesignatedRouterID;
    Ipv4Address *neighborID = nullptr;
    size_t neighborID_arraysize = 0;

  private:
    void copy(const Ospfv3HelloPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv3HelloPacket&);

  public:
    Ospfv3HelloPacket();
    Ospfv3HelloPacket(const Ospfv3HelloPacket& other);
    virtual ~Ospfv3HelloPacket();
    Ospfv3HelloPacket& operator=(const Ospfv3HelloPacket& other);
    virtual Ospfv3HelloPacket *dup() const override {return new Ospfv3HelloPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getInterfaceID() const;
    virtual void setInterfaceID(uint32_t interfaceID);
    virtual char getRouterPriority() const;
    virtual void setRouterPriority(char routerPriority);
    virtual const Ospfv3Options& getOptions() const;
    virtual Ospfv3Options& getOptionsForUpdate() { handleChange();return const_cast<Ospfv3Options&>(const_cast<Ospfv3HelloPacket*>(this)->getOptions());}
    virtual void setOptions(const Ospfv3Options& options);
    virtual uint16_t getHelloInterval() const;
    virtual void setHelloInterval(uint16_t helloInterval);
    virtual uint16_t getDeadInterval() const;
    virtual void setDeadInterval(uint16_t deadInterval);
    virtual const Ipv4Address& getDesignatedRouterID() const;
    virtual Ipv4Address& getDesignatedRouterIDForUpdate() { handleChange();return const_cast<Ipv4Address&>(const_cast<Ospfv3HelloPacket*>(this)->getDesignatedRouterID());}
    virtual void setDesignatedRouterID(const Ipv4Address& designatedRouterID);
    virtual const Ipv4Address& getBackupDesignatedRouterID() const;
    virtual Ipv4Address& getBackupDesignatedRouterIDForUpdate() { handleChange();return const_cast<Ipv4Address&>(const_cast<Ospfv3HelloPacket*>(this)->getBackupDesignatedRouterID());}
    virtual void setBackupDesignatedRouterID(const Ipv4Address& backupDesignatedRouterID);
    virtual void setNeighborIDArraySize(size_t size);
    virtual size_t getNeighborIDArraySize() const;
    virtual const Ipv4Address& getNeighborID(size_t k) const;
    virtual Ipv4Address& getNeighborIDForUpdate(size_t k) { handleChange();return const_cast<Ipv4Address&>(const_cast<Ospfv3HelloPacket*>(this)->getNeighborID(k));}
    virtual void setNeighborID(size_t k, const Ipv4Address& neighborID);
    virtual void insertNeighborID(const Ipv4Address& neighborID);
    virtual void insertNeighborID(size_t k, const Ipv4Address& neighborID);
    virtual void eraseNeighborID(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv3HelloPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv3HelloPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv3/Ospfv3Packet.msg:81</tt> by nedtool.
 * <pre>
 * //Common LSA Header - this header is present in every LSA
 * //triplet {lsType, linkStateID, advertisingRouter} uniquely identify the LSA
 * class Ospfv3LsaHeader extends cObject
 * {
 *     unsigned short lsaAge;          // [sec] 16 bits
 *     unsigned short options;         // 8 bits
 *     unsigned short lsaType;         // 8 bits
 *     Ipv4Address linkStateID;        // 32 bits
 *     Ipv4Address advertisingRouter;  // 32 bits
 *     uint32_t lsaSequenceNumber;     // 32 bits
 *     uint16_t lsaChecksum;     // 16 bits
 *     CrcMode lsCrcMode = CRC_MODE_UNDEFINED;
 *     uint16_t lsaLength;
 * }
 * </pre>
 */
class INET_API Ospfv3LsaHeader : public ::omnetpp::cObject
{
  protected:
    unsigned short lsaAge = 0;
    unsigned short options = 0;
    unsigned short lsaType = 0;
    Ipv4Address linkStateID;
    Ipv4Address advertisingRouter;
    uint32_t lsaSequenceNumber = 0;
    uint16_t lsaChecksum = 0;
    inet::CrcMode lsCrcMode = CRC_MODE_UNDEFINED;
    uint16_t lsaLength = 0;

  private:
    void copy(const Ospfv3LsaHeader& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv3LsaHeader&);

  public:
    Ospfv3LsaHeader();
    Ospfv3LsaHeader(const Ospfv3LsaHeader& other);
    virtual ~Ospfv3LsaHeader();
    Ospfv3LsaHeader& operator=(const Ospfv3LsaHeader& other);
    virtual Ospfv3LsaHeader *dup() const override {return new Ospfv3LsaHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned short getLsaAge() const;
    virtual void setLsaAge(unsigned short lsaAge);
    virtual unsigned short getOptions() const;
    virtual void setOptions(unsigned short options);
    virtual unsigned short getLsaType() const;
    virtual void setLsaType(unsigned short lsaType);
    virtual const Ipv4Address& getLinkStateID() const;
    virtual Ipv4Address& getLinkStateIDForUpdate() { return const_cast<Ipv4Address&>(const_cast<Ospfv3LsaHeader*>(this)->getLinkStateID());}
    virtual void setLinkStateID(const Ipv4Address& linkStateID);
    virtual const Ipv4Address& getAdvertisingRouter() const;
    virtual Ipv4Address& getAdvertisingRouterForUpdate() { return const_cast<Ipv4Address&>(const_cast<Ospfv3LsaHeader*>(this)->getAdvertisingRouter());}
    virtual void setAdvertisingRouter(const Ipv4Address& advertisingRouter);
    virtual uint32_t getLsaSequenceNumber() const;
    virtual void setLsaSequenceNumber(uint32_t lsaSequenceNumber);
    virtual uint16_t getLsaChecksum() const;
    virtual void setLsaChecksum(uint16_t lsaChecksum);
    virtual inet::CrcMode getLsCrcMode() const;
    virtual void setLsCrcMode(inet::CrcMode lsCrcMode);
    virtual uint16_t getLsaLength() const;
    virtual void setLsaLength(uint16_t lsaLength);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv3LsaHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv3LsaHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv3/Ospfv3Packet.msg:94</tt> by nedtool.
 * <pre>
 * class Ospfv3Lsa extends cObject
 * {
 *     Ospfv3LsaHeader header;
 * }
 * </pre>
 */
class INET_API Ospfv3Lsa : public ::omnetpp::cObject
{
  protected:
    Ospfv3LsaHeader header;

  private:
    void copy(const Ospfv3Lsa& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv3Lsa&);

  public:
    Ospfv3Lsa();
    Ospfv3Lsa(const Ospfv3Lsa& other);
    virtual ~Ospfv3Lsa();
    Ospfv3Lsa& operator=(const Ospfv3Lsa& other);
    virtual Ospfv3Lsa *dup() const override {return new Ospfv3Lsa(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ospfv3LsaHeader& getHeader() const;
    virtual Ospfv3LsaHeader& getHeaderForUpdate() { return const_cast<Ospfv3LsaHeader&>(const_cast<Ospfv3Lsa*>(this)->getHeader());}
    virtual void setHeader(const Ospfv3LsaHeader& header);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv3Lsa& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv3Lsa& obj) {obj.parsimUnpack(b);}

/**
 * Enum generated from <tt>inet/routing/ospfv3/Ospfv3Packet.msg:100</tt> by nedtool.
 * <pre>
 * //LSA Function Code
 * enum Ospfv3LsaFunctionCode
 * {
 *     ROUTER_LSA = 1;
 *     NETWORK_LSA = 2;
 *     INTER_AREA_PREFIX_LSA = 3;
 *     INTER_AREA_ROUTER_LSA = 4;
 *     AS_EXTERNAL_LSA = 5;
 *     DEPRECATED = 6;
 *     NSSA_LSA = 7;
 *     LINK_LSA = 8;
 *     INTRA_AREA_PREFIX_LSA = 9;
 * }
 * </pre>
 */
enum Ospfv3LsaFunctionCode {
    ROUTER_LSA = 1,
    NETWORK_LSA = 2,
    INTER_AREA_PREFIX_LSA = 3,
    INTER_AREA_ROUTER_LSA = 4,
    AS_EXTERNAL_LSA = 5,
    DEPRECATED = 6,
    NSSA_LSA = 7,
    LINK_LSA = 8,
    INTRA_AREA_PREFIX_LSA = 9
};

/**
 * Struct generated from inet/routing/ospfv3/Ospfv3Packet.msg:114 by nedtool.
 */
struct INET_API Ospfv3LsaPrefixMetric
{
    Ospfv3LsaPrefixMetric();
    bool reserved1;
    bool reserved2;
    bool reserved3;
    bool dnBit;
    bool pBit;
    bool xBit;
    bool laBit;
    bool nuBit;
    uint8_t prefixLen;
    uint16_t metric;
    L3Address addressPrefix;

bool operator ==(const Ospfv3LsaPrefixMetric& b) const
{
	return (dnBit == b.dnBit)
		&& (pBit == b.pBit)
		&& (xBit == b.xBit)
		&& (laBit == b.laBit)
		&& (nuBit == b.nuBit)
		&& (prefixLen == b.prefixLen)
		&& (metric == b.metric)
		&& (addressPrefix == b.addressPrefix)
		;
}

bool operator !=(const Ospfv3LsaPrefixMetric& b) const { return ! (*this == b); }

};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const Ospfv3LsaPrefixMetric& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, Ospfv3LsaPrefixMetric& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv3LsaPrefixMetric& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv3LsaPrefixMetric& obj) { __doUnpacking(b, obj); }

/**
 * Struct generated from inet/routing/ospfv3/Ospfv3Packet.msg:149 by nedtool.
 */
struct INET_API Ospfv3LsaPrefix0
{
    Ospfv3LsaPrefix0();
    bool reserved1;
    bool reserved2;
    bool reserved3;
    bool dnBit;
    bool pBit;
    bool xBit;
    bool laBit;
    bool nuBit;
    uint8_t prefixLen;
    uint16_t reserved;
    L3Address addressPrefix;

bool operator ==(const Ospfv3LsaPrefix0& b) const
{
	return (dnBit == b.dnBit)
		&& (pBit == b.pBit)
		&& (xBit == b.xBit)
		&& (laBit == b.laBit)
		&& (nuBit == b.nuBit)
		&& (prefixLen == b.prefixLen)
		&& (addressPrefix == b.addressPrefix)
		;
}

bool operator !=(const Ospfv3LsaPrefix0& b) const { return ! (*this == b); }

};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const Ospfv3LsaPrefix0& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, Ospfv3LsaPrefix0& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv3LsaPrefix0& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv3LsaPrefix0& obj) { __doUnpacking(b, obj); }

/**
 * Enum generated from <tt>inet/routing/ospfv3/Ospfv3Packet.msg:183</tt> by nedtool.
 * <pre>
 * //Router LSA
 * enum Ospfv3RouterLsaType
 * {
 *     POINT_TO_POINT = 1;
 *     TRANSIT_NETWORK = 2;
 *     RESERVED = 3;
 *     VIRTUAL_LINK = 4;
 * }
 * </pre>
 */
enum Ospfv3RouterLsaType {
    POINT_TO_POINT = 1,
    TRANSIT_NETWORK = 2,
    RESERVED = 3,
    VIRTUAL_LINK = 4
};

/**
 * Struct generated from inet/routing/ospfv3/Ospfv3Packet.msg:191 by nedtool.
 */
struct INET_API Ospfv3RouterLsaBody
{
    Ospfv3RouterLsaBody();
    uint8_t type;
    uint16_t metric;
    uint32_t interfaceID;
    uint32_t neighborInterfaceID;
    Ipv4Address neighborRouterID;
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const Ospfv3RouterLsaBody& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, Ospfv3RouterLsaBody& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv3RouterLsaBody& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv3RouterLsaBody& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>inet/routing/ospfv3/Ospfv3Packet.msg:201</tt> by nedtool.
 * <pre>
 * class Ospfv3RouterLsa extends Ospfv3Lsa
 * {
 *     bool ntBit;
 *     bool xBit;
 *     bool vBit;
 *     bool eBit;
 *     bool bBit;
 *     Ospfv3Options ospfOptions;
 * 
 *     Ospfv3RouterLsaBody routers[];
 * }
 * </pre>
 */
class INET_API Ospfv3RouterLsa : public ::inet::ospfv3::Ospfv3Lsa
{
  protected:
    bool ntBit = false;
    bool xBit = false;
    bool vBit = false;
    bool eBit = false;
    bool bBit = false;
    Ospfv3Options ospfOptions;
    Ospfv3RouterLsaBody *routers = nullptr;
    size_t routers_arraysize = 0;

  private:
    void copy(const Ospfv3RouterLsa& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv3RouterLsa&);

  public:
    Ospfv3RouterLsa();
    Ospfv3RouterLsa(const Ospfv3RouterLsa& other);
    virtual ~Ospfv3RouterLsa();
    Ospfv3RouterLsa& operator=(const Ospfv3RouterLsa& other);
    virtual Ospfv3RouterLsa *dup() const override {return new Ospfv3RouterLsa(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getNtBit() const;
    virtual void setNtBit(bool ntBit);
    virtual bool getXBit() const;
    virtual void setXBit(bool xBit);
    virtual bool getVBit() const;
    virtual void setVBit(bool vBit);
    virtual bool getEBit() const;
    virtual void setEBit(bool eBit);
    virtual bool getBBit() const;
    virtual void setBBit(bool bBit);
    virtual const Ospfv3Options& getOspfOptions() const;
    virtual Ospfv3Options& getOspfOptionsForUpdate() { return const_cast<Ospfv3Options&>(const_cast<Ospfv3RouterLsa*>(this)->getOspfOptions());}
    virtual void setOspfOptions(const Ospfv3Options& ospfOptions);
    virtual void setRoutersArraySize(size_t size);
    virtual size_t getRoutersArraySize() const;
    virtual const Ospfv3RouterLsaBody& getRouters(size_t k) const;
    virtual Ospfv3RouterLsaBody& getRoutersForUpdate(size_t k) { return const_cast<Ospfv3RouterLsaBody&>(const_cast<Ospfv3RouterLsa*>(this)->getRouters(k));}
    virtual void setRouters(size_t k, const Ospfv3RouterLsaBody& routers);
    virtual void insertRouters(const Ospfv3RouterLsaBody& routers);
    virtual void insertRouters(size_t k, const Ospfv3RouterLsaBody& routers);
    virtual void eraseRouters(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv3RouterLsa& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv3RouterLsa& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv3/Ospfv3Packet.msg:214</tt> by nedtool.
 * <pre>
 * //Network LSA
 * class Ospfv3NetworkLsa extends Ospfv3Lsa
 * {
 *     Ospfv3Options ospfOptions;
 * 
 *     Ipv4Address attachedRouter[];
 * }
 * </pre>
 */
class INET_API Ospfv3NetworkLsa : public ::inet::ospfv3::Ospfv3Lsa
{
  protected:
    Ospfv3Options ospfOptions;
    Ipv4Address *attachedRouter = nullptr;
    size_t attachedRouter_arraysize = 0;

  private:
    void copy(const Ospfv3NetworkLsa& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv3NetworkLsa&);

  public:
    Ospfv3NetworkLsa();
    Ospfv3NetworkLsa(const Ospfv3NetworkLsa& other);
    virtual ~Ospfv3NetworkLsa();
    Ospfv3NetworkLsa& operator=(const Ospfv3NetworkLsa& other);
    virtual Ospfv3NetworkLsa *dup() const override {return new Ospfv3NetworkLsa(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ospfv3Options& getOspfOptions() const;
    virtual Ospfv3Options& getOspfOptionsForUpdate() { return const_cast<Ospfv3Options&>(const_cast<Ospfv3NetworkLsa*>(this)->getOspfOptions());}
    virtual void setOspfOptions(const Ospfv3Options& ospfOptions);
    virtual void setAttachedRouterArraySize(size_t size);
    virtual size_t getAttachedRouterArraySize() const;
    virtual const Ipv4Address& getAttachedRouter(size_t k) const;
    virtual Ipv4Address& getAttachedRouterForUpdate(size_t k) { return const_cast<Ipv4Address&>(const_cast<Ospfv3NetworkLsa*>(this)->getAttachedRouter(k));}
    virtual void setAttachedRouter(size_t k, const Ipv4Address& attachedRouter);
    virtual void insertAttachedRouter(const Ipv4Address& attachedRouter);
    virtual void insertAttachedRouter(size_t k, const Ipv4Address& attachedRouter);
    virtual void eraseAttachedRouter(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv3NetworkLsa& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv3NetworkLsa& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv3/Ospfv3Packet.msg:222</tt> by nedtool.
 * <pre>
 * // Inter-Area-Prefix-LSAs
 * class Ospfv3InterAreaPrefixLsa extends Ospfv3Lsa
 * {
 *     uint8_t reserved1 = 0;		// 8 bits
 *     uint32_t metric;			// 24 bits
 *     Ospfv3LsaPrefix0 prefix;
 * }
 * </pre>
 */
class INET_API Ospfv3InterAreaPrefixLsa : public ::inet::ospfv3::Ospfv3Lsa
{
  protected:
    uint8_t reserved1 = 0;
    uint32_t metric = 0;
    Ospfv3LsaPrefix0 prefix;

  private:
    void copy(const Ospfv3InterAreaPrefixLsa& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv3InterAreaPrefixLsa&);

  public:
    Ospfv3InterAreaPrefixLsa();
    Ospfv3InterAreaPrefixLsa(const Ospfv3InterAreaPrefixLsa& other);
    virtual ~Ospfv3InterAreaPrefixLsa();
    Ospfv3InterAreaPrefixLsa& operator=(const Ospfv3InterAreaPrefixLsa& other);
    virtual Ospfv3InterAreaPrefixLsa *dup() const override {return new Ospfv3InterAreaPrefixLsa(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint8_t getReserved1() const;
    virtual void setReserved1(uint8_t reserved1);
    virtual uint32_t getMetric() const;
    virtual void setMetric(uint32_t metric);
    virtual const Ospfv3LsaPrefix0& getPrefix() const;
    virtual Ospfv3LsaPrefix0& getPrefixForUpdate() { return const_cast<Ospfv3LsaPrefix0&>(const_cast<Ospfv3InterAreaPrefixLsa*>(this)->getPrefix());}
    virtual void setPrefix(const Ospfv3LsaPrefix0& prefix);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv3InterAreaPrefixLsa& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv3InterAreaPrefixLsa& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv3/Ospfv3Packet.msg:230</tt> by nedtool.
 * <pre>
 * //Inter-Area-Router-LSAs
 * class Ospfv3InterAreaRouterLsa extends Ospfv3Lsa
 * {
 *     Ospfv3Options ospfOptions;
 *     uint32_t metric;
 *     uint32_t destinationRouter;
 * }
 * </pre>
 */
class INET_API Ospfv3InterAreaRouterLsa : public ::inet::ospfv3::Ospfv3Lsa
{
  protected:
    Ospfv3Options ospfOptions;
    uint32_t metric = 0;
    uint32_t destinationRouter = 0;

  private:
    void copy(const Ospfv3InterAreaRouterLsa& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv3InterAreaRouterLsa&);

  public:
    Ospfv3InterAreaRouterLsa();
    Ospfv3InterAreaRouterLsa(const Ospfv3InterAreaRouterLsa& other);
    virtual ~Ospfv3InterAreaRouterLsa();
    Ospfv3InterAreaRouterLsa& operator=(const Ospfv3InterAreaRouterLsa& other);
    virtual Ospfv3InterAreaRouterLsa *dup() const override {return new Ospfv3InterAreaRouterLsa(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ospfv3Options& getOspfOptions() const;
    virtual Ospfv3Options& getOspfOptionsForUpdate() { return const_cast<Ospfv3Options&>(const_cast<Ospfv3InterAreaRouterLsa*>(this)->getOspfOptions());}
    virtual void setOspfOptions(const Ospfv3Options& ospfOptions);
    virtual uint32_t getMetric() const;
    virtual void setMetric(uint32_t metric);
    virtual uint32_t getDestinationRouter() const;
    virtual void setDestinationRouter(uint32_t destinationRouter);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv3InterAreaRouterLsa& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv3InterAreaRouterLsa& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv3/Ospfv3Packet.msg:238</tt> by nedtool.
 * <pre>
 * //   AS-External-LSAs
 * class Ospfv3AsExternalLsa extends Ospfv3Lsa
 * {
 *     bool eBit;
 *     bool fBit;
 *     bool tBit;
 *     uint32_t metric;
 * 
 *     uint16_t referencedLSType;
 * 
 *     Ipv6Address forwardingAddress;
 *     uint32_t externalRouteTag;
 *     uint32_t referencedLSID;
 * }
 * </pre>
 */
class INET_API Ospfv3AsExternalLsa : public ::inet::ospfv3::Ospfv3Lsa
{
  protected:
    bool eBit = false;
    bool fBit = false;
    bool tBit = false;
    uint32_t metric = 0;
    uint16_t referencedLSType = 0;
    Ipv6Address forwardingAddress;
    uint32_t externalRouteTag = 0;
    uint32_t referencedLSID = 0;

  private:
    void copy(const Ospfv3AsExternalLsa& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv3AsExternalLsa&);

  public:
    Ospfv3AsExternalLsa();
    Ospfv3AsExternalLsa(const Ospfv3AsExternalLsa& other);
    virtual ~Ospfv3AsExternalLsa();
    Ospfv3AsExternalLsa& operator=(const Ospfv3AsExternalLsa& other);
    virtual Ospfv3AsExternalLsa *dup() const override {return new Ospfv3AsExternalLsa(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getEBit() const;
    virtual void setEBit(bool eBit);
    virtual bool getFBit() const;
    virtual void setFBit(bool fBit);
    virtual bool getTBit() const;
    virtual void setTBit(bool tBit);
    virtual uint32_t getMetric() const;
    virtual void setMetric(uint32_t metric);
    virtual uint16_t getReferencedLSType() const;
    virtual void setReferencedLSType(uint16_t referencedLSType);
    virtual const Ipv6Address& getForwardingAddress() const;
    virtual Ipv6Address& getForwardingAddressForUpdate() { return const_cast<Ipv6Address&>(const_cast<Ospfv3AsExternalLsa*>(this)->getForwardingAddress());}
    virtual void setForwardingAddress(const Ipv6Address& forwardingAddress);
    virtual uint32_t getExternalRouteTag() const;
    virtual void setExternalRouteTag(uint32_t externalRouteTag);
    virtual uint32_t getReferencedLSID() const;
    virtual void setReferencedLSID(uint32_t referencedLSID);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv3AsExternalLsa& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv3AsExternalLsa& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv3/Ospfv3Packet.msg:257</tt> by nedtool.
 * <pre>
 * //   NSSA-LSAs
 * // Routers in a Not-so-stubby-area (NSSA) do not receive external LSAs from Area Border Routers,
 * // but are allowed to send external routing information for redistribution.
 * // They use type 7 LSAs to tell the ABRs about these external routes,
 * // which the Area Border Router then translates to type 5 external LSAs and floods as normal to the rest of the OSPF network
 * class Ospfv3NssaLsa extends Ospfv3Lsa
 * {
 *     bool eBit;
 *     bool fBit;
 *     bool tBit;
 *     uint32_t metric;
 * 
 *     Ospfv3LsaPrefixMetric prefOptions;
 *     uint16_t referencedLSType;
 * 
 *     Ipv6Address forwardingAddress;
 *     uint32_t externalRouteTag;
 *     uint32_t referencedLSID;
 * }
 * </pre>
 */
class INET_API Ospfv3NssaLsa : public ::inet::ospfv3::Ospfv3Lsa
{
  protected:
    bool eBit = false;
    bool fBit = false;
    bool tBit = false;
    uint32_t metric = 0;
    Ospfv3LsaPrefixMetric prefOptions;
    uint16_t referencedLSType = 0;
    Ipv6Address forwardingAddress;
    uint32_t externalRouteTag = 0;
    uint32_t referencedLSID = 0;

  private:
    void copy(const Ospfv3NssaLsa& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv3NssaLsa&);

  public:
    Ospfv3NssaLsa();
    Ospfv3NssaLsa(const Ospfv3NssaLsa& other);
    virtual ~Ospfv3NssaLsa();
    Ospfv3NssaLsa& operator=(const Ospfv3NssaLsa& other);
    virtual Ospfv3NssaLsa *dup() const override {return new Ospfv3NssaLsa(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getEBit() const;
    virtual void setEBit(bool eBit);
    virtual bool getFBit() const;
    virtual void setFBit(bool fBit);
    virtual bool getTBit() const;
    virtual void setTBit(bool tBit);
    virtual uint32_t getMetric() const;
    virtual void setMetric(uint32_t metric);
    virtual const Ospfv3LsaPrefixMetric& getPrefOptions() const;
    virtual Ospfv3LsaPrefixMetric& getPrefOptionsForUpdate() { return const_cast<Ospfv3LsaPrefixMetric&>(const_cast<Ospfv3NssaLsa*>(this)->getPrefOptions());}
    virtual void setPrefOptions(const Ospfv3LsaPrefixMetric& prefOptions);
    virtual uint16_t getReferencedLSType() const;
    virtual void setReferencedLSType(uint16_t referencedLSType);
    virtual const Ipv6Address& getForwardingAddress() const;
    virtual Ipv6Address& getForwardingAddressForUpdate() { return const_cast<Ipv6Address&>(const_cast<Ospfv3NssaLsa*>(this)->getForwardingAddress());}
    virtual void setForwardingAddress(const Ipv6Address& forwardingAddress);
    virtual uint32_t getExternalRouteTag() const;
    virtual void setExternalRouteTag(uint32_t externalRouteTag);
    virtual uint32_t getReferencedLSID() const;
    virtual void setReferencedLSID(uint32_t referencedLSID);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv3NssaLsa& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv3NssaLsa& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv3/Ospfv3Packet.msg:275</tt> by nedtool.
 * <pre>
 * // Link-LSAs
 * // A link-local only LSA for OSPFv3. A Type 8 LSA is used to give
 * // information about link-local addresses and a list of IPv6 addresses on the link.
 * class Ospfv3LinkLsa extends Ospfv3Lsa
 * {
 *     uint8_t routerPriority;
 *     Ospfv3Options ospfOptions;
 * 
 *     L3Address linkLocalInterfaceAdd;
 * 
 *     uint32_t numPrefixes;
 *     Ospfv3LsaPrefix0 prefixes[];
 * }
 * </pre>
 */
class INET_API Ospfv3LinkLsa : public ::inet::ospfv3::Ospfv3Lsa
{
  protected:
    uint8_t routerPriority = 0;
    Ospfv3Options ospfOptions;
    L3Address linkLocalInterfaceAdd;
    uint32_t numPrefixes = 0;
    Ospfv3LsaPrefix0 *prefixes = nullptr;
    size_t prefixes_arraysize = 0;

  private:
    void copy(const Ospfv3LinkLsa& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv3LinkLsa&);

  public:
    Ospfv3LinkLsa();
    Ospfv3LinkLsa(const Ospfv3LinkLsa& other);
    virtual ~Ospfv3LinkLsa();
    Ospfv3LinkLsa& operator=(const Ospfv3LinkLsa& other);
    virtual Ospfv3LinkLsa *dup() const override {return new Ospfv3LinkLsa(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint8_t getRouterPriority() const;
    virtual void setRouterPriority(uint8_t routerPriority);
    virtual const Ospfv3Options& getOspfOptions() const;
    virtual Ospfv3Options& getOspfOptionsForUpdate() { return const_cast<Ospfv3Options&>(const_cast<Ospfv3LinkLsa*>(this)->getOspfOptions());}
    virtual void setOspfOptions(const Ospfv3Options& ospfOptions);
    virtual const L3Address& getLinkLocalInterfaceAdd() const;
    virtual L3Address& getLinkLocalInterfaceAddForUpdate() { return const_cast<L3Address&>(const_cast<Ospfv3LinkLsa*>(this)->getLinkLocalInterfaceAdd());}
    virtual void setLinkLocalInterfaceAdd(const L3Address& linkLocalInterfaceAdd);
    virtual uint32_t getNumPrefixes() const;
    virtual void setNumPrefixes(uint32_t numPrefixes);
    virtual void setPrefixesArraySize(size_t size);
    virtual size_t getPrefixesArraySize() const;
    virtual const Ospfv3LsaPrefix0& getPrefixes(size_t k) const;
    virtual Ospfv3LsaPrefix0& getPrefixesForUpdate(size_t k) { return const_cast<Ospfv3LsaPrefix0&>(const_cast<Ospfv3LinkLsa*>(this)->getPrefixes(k));}
    virtual void setPrefixes(size_t k, const Ospfv3LsaPrefix0& prefixes);
    virtual void insertPrefixes(const Ospfv3LsaPrefix0& prefixes);
    virtual void insertPrefixes(size_t k, const Ospfv3LsaPrefix0& prefixes);
    virtual void erasePrefixes(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv3LinkLsa& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv3LinkLsa& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv3/Ospfv3Packet.msg:287</tt> by nedtool.
 * <pre>
 * // Intra-Area-Prefix-LSAs
 * class Ospfv3IntraAreaPrefixLsa extends Ospfv3Lsa
 * {
 *     unsigned short numPrefixes;
 *     unsigned short referencedLSType;
 *     Ipv4Address referencedLSID;
 *     Ipv4Address referencedAdvRtr;
 * 
 *     Ospfv3LsaPrefixMetric prefixes[];
 * }
 * </pre>
 */
class INET_API Ospfv3IntraAreaPrefixLsa : public ::inet::ospfv3::Ospfv3Lsa
{
  protected:
    unsigned short numPrefixes = 0;
    unsigned short referencedLSType = 0;
    Ipv4Address referencedLSID;
    Ipv4Address referencedAdvRtr;
    Ospfv3LsaPrefixMetric *prefixes = nullptr;
    size_t prefixes_arraysize = 0;

  private:
    void copy(const Ospfv3IntraAreaPrefixLsa& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv3IntraAreaPrefixLsa&);

  public:
    Ospfv3IntraAreaPrefixLsa();
    Ospfv3IntraAreaPrefixLsa(const Ospfv3IntraAreaPrefixLsa& other);
    virtual ~Ospfv3IntraAreaPrefixLsa();
    Ospfv3IntraAreaPrefixLsa& operator=(const Ospfv3IntraAreaPrefixLsa& other);
    virtual Ospfv3IntraAreaPrefixLsa *dup() const override {return new Ospfv3IntraAreaPrefixLsa(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned short getNumPrefixes() const;
    virtual void setNumPrefixes(unsigned short numPrefixes);
    virtual unsigned short getReferencedLSType() const;
    virtual void setReferencedLSType(unsigned short referencedLSType);
    virtual const Ipv4Address& getReferencedLSID() const;
    virtual Ipv4Address& getReferencedLSIDForUpdate() { return const_cast<Ipv4Address&>(const_cast<Ospfv3IntraAreaPrefixLsa*>(this)->getReferencedLSID());}
    virtual void setReferencedLSID(const Ipv4Address& referencedLSID);
    virtual const Ipv4Address& getReferencedAdvRtr() const;
    virtual Ipv4Address& getReferencedAdvRtrForUpdate() { return const_cast<Ipv4Address&>(const_cast<Ospfv3IntraAreaPrefixLsa*>(this)->getReferencedAdvRtr());}
    virtual void setReferencedAdvRtr(const Ipv4Address& referencedAdvRtr);
    virtual void setPrefixesArraySize(size_t size);
    virtual size_t getPrefixesArraySize() const;
    virtual const Ospfv3LsaPrefixMetric& getPrefixes(size_t k) const;
    virtual Ospfv3LsaPrefixMetric& getPrefixesForUpdate(size_t k) { return const_cast<Ospfv3LsaPrefixMetric&>(const_cast<Ospfv3IntraAreaPrefixLsa*>(this)->getPrefixes(k));}
    virtual void setPrefixes(size_t k, const Ospfv3LsaPrefixMetric& prefixes);
    virtual void insertPrefixes(const Ospfv3LsaPrefixMetric& prefixes);
    virtual void insertPrefixes(size_t k, const Ospfv3LsaPrefixMetric& prefixes);
    virtual void erasePrefixes(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv3IntraAreaPrefixLsa& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv3IntraAreaPrefixLsa& obj) {obj.parsimUnpack(b);}

/**
 * Struct generated from inet/routing/ospfv3/Ospfv3Packet.msg:298 by nedtool.
 */
struct INET_API Ospfv3DdOptions
{
    Ospfv3DdOptions();
    uint16_t reserved;
    bool iBit;
    bool mBit;
    bool msBit;
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const Ospfv3DdOptions& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, Ospfv3DdOptions& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv3DdOptions& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv3DdOptions& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>inet/routing/ospfv3/Ospfv3Packet.msg:309</tt> by nedtool.
 * <pre>
 * //
 * // Database Description Packet
 * //
 * class Ospfv3DatabaseDescriptionPacket extends Ospfv3Packet
 * {
 *     type = ospf::DATABASE_DESCRIPTION_PACKET;
 *     uint8_t reserved1 = 0;      //  8 bits
 *     Ospfv3Options options;      // 24 bits
 *     uint16_t interfaceMTU;      // 16 bits
 *     Ospfv3DdOptions ddOptions;  // 16 bits
 *     uint32_t sequenceNumber;    // 32 bits
 * 
 *     Ospfv3LsaHeader lsaHeaders[];
 * }
 * 
 * //
 * // Link State Request
 * //
 * </pre>
 */
class INET_API Ospfv3DatabaseDescriptionPacket : public ::inet::ospfv3::Ospfv3Packet
{
  protected:
    uint8_t reserved1 = 0;
    Ospfv3Options options;
    uint16_t interfaceMTU = 0;
    Ospfv3DdOptions ddOptions;
    uint32_t sequenceNumber = 0;
    Ospfv3LsaHeader *lsaHeaders = nullptr;
    size_t lsaHeaders_arraysize = 0;

  private:
    void copy(const Ospfv3DatabaseDescriptionPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv3DatabaseDescriptionPacket&);

  public:
    Ospfv3DatabaseDescriptionPacket();
    Ospfv3DatabaseDescriptionPacket(const Ospfv3DatabaseDescriptionPacket& other);
    virtual ~Ospfv3DatabaseDescriptionPacket();
    Ospfv3DatabaseDescriptionPacket& operator=(const Ospfv3DatabaseDescriptionPacket& other);
    virtual Ospfv3DatabaseDescriptionPacket *dup() const override {return new Ospfv3DatabaseDescriptionPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint8_t getReserved1() const;
    virtual void setReserved1(uint8_t reserved1);
    virtual const Ospfv3Options& getOptions() const;
    virtual Ospfv3Options& getOptionsForUpdate() { handleChange();return const_cast<Ospfv3Options&>(const_cast<Ospfv3DatabaseDescriptionPacket*>(this)->getOptions());}
    virtual void setOptions(const Ospfv3Options& options);
    virtual uint16_t getInterfaceMTU() const;
    virtual void setInterfaceMTU(uint16_t interfaceMTU);
    virtual const Ospfv3DdOptions& getDdOptions() const;
    virtual Ospfv3DdOptions& getDdOptionsForUpdate() { handleChange();return const_cast<Ospfv3DdOptions&>(const_cast<Ospfv3DatabaseDescriptionPacket*>(this)->getDdOptions());}
    virtual void setDdOptions(const Ospfv3DdOptions& ddOptions);
    virtual uint32_t getSequenceNumber() const;
    virtual void setSequenceNumber(uint32_t sequenceNumber);
    virtual void setLsaHeadersArraySize(size_t size);
    virtual size_t getLsaHeadersArraySize() const;
    virtual const Ospfv3LsaHeader& getLsaHeaders(size_t k) const;
    virtual Ospfv3LsaHeader& getLsaHeadersForUpdate(size_t k) { handleChange();return const_cast<Ospfv3LsaHeader&>(const_cast<Ospfv3DatabaseDescriptionPacket*>(this)->getLsaHeaders(k));}
    virtual void setLsaHeaders(size_t k, const Ospfv3LsaHeader& lsaHeaders);
    virtual void insertLsaHeaders(const Ospfv3LsaHeader& lsaHeaders);
    virtual void insertLsaHeaders(size_t k, const Ospfv3LsaHeader& lsaHeaders);
    virtual void eraseLsaHeaders(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv3DatabaseDescriptionPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv3DatabaseDescriptionPacket& obj) {obj.parsimUnpack(b);}

/**
 * Struct generated from inet/routing/ospfv3/Ospfv3Packet.msg:326 by nedtool.
 */
struct INET_API Ospfv3LsRequest
{
    Ospfv3LsRequest();
    uint16_t lsaType;
    Ipv4Address lsaID;
    Ipv4Address advertisingRouter;
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const Ospfv3LsRequest& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, Ospfv3LsRequest& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv3LsRequest& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv3LsRequest& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>inet/routing/ospfv3/Ospfv3Packet.msg:334</tt> by nedtool.
 * <pre>
 * //Link State Request packet
 * class Ospfv3LinkStateRequestPacket extends Ospfv3Packet
 * {
 *     Ospfv3LsRequest requests[];
 * }
 * 
 * //
 * // Link State Update
 * //
 * </pre>
 */
class INET_API Ospfv3LinkStateRequestPacket : public ::inet::ospfv3::Ospfv3Packet
{
  protected:
    Ospfv3LsRequest *requests = nullptr;
    size_t requests_arraysize = 0;

  private:
    void copy(const Ospfv3LinkStateRequestPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv3LinkStateRequestPacket&);

  public:
    Ospfv3LinkStateRequestPacket();
    Ospfv3LinkStateRequestPacket(const Ospfv3LinkStateRequestPacket& other);
    virtual ~Ospfv3LinkStateRequestPacket();
    Ospfv3LinkStateRequestPacket& operator=(const Ospfv3LinkStateRequestPacket& other);
    virtual Ospfv3LinkStateRequestPacket *dup() const override {return new Ospfv3LinkStateRequestPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setRequestsArraySize(size_t size);
    virtual size_t getRequestsArraySize() const;
    virtual const Ospfv3LsRequest& getRequests(size_t k) const;
    virtual Ospfv3LsRequest& getRequestsForUpdate(size_t k) { handleChange();return const_cast<Ospfv3LsRequest&>(const_cast<Ospfv3LinkStateRequestPacket*>(this)->getRequests(k));}
    virtual void setRequests(size_t k, const Ospfv3LsRequest& requests);
    virtual void insertRequests(const Ospfv3LsRequest& requests);
    virtual void insertRequests(size_t k, const Ospfv3LsRequest& requests);
    virtual void eraseRequests(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv3LinkStateRequestPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv3LinkStateRequestPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv3/Ospfv3Packet.msg:344</tt> by nedtool.
 * <pre>
 * //Link State Update packet
 * class Ospfv3LinkStateUpdatePacket extends Ospfv3Packet
 * {
 *     uint32_t lsaCount;  //specifies the number of LSAs sent in a single packet
 * 
 *     Ospfv3RouterLsa RouterLSAs[];
 *     Ospfv3NetworkLsa NetworkLSAs[];
 *     Ospfv3InterAreaPrefixLsa InterAreaPrefixLSAs[];
 *     Ospfv3LinkLsa LinkLSAs[];
 *     Ospfv3IntraAreaPrefixLsa IntraAreaPrefixLSAs[];
 *     // Ospfv3Lsa *LSAs[] \@owned \@allowReplace;
 *     //TODO - see Ospfv2LinkStateUpdatePacket
 * }
 * 
 * //
 * // Link State Acknowledgement
 * //
 * </pre>
 */
class INET_API Ospfv3LinkStateUpdatePacket : public ::inet::ospfv3::Ospfv3Packet
{
  protected:
    uint32_t lsaCount = 0;
    Ospfv3RouterLsa *RouterLSAs = nullptr;
    size_t RouterLSAs_arraysize = 0;
    Ospfv3NetworkLsa *NetworkLSAs = nullptr;
    size_t NetworkLSAs_arraysize = 0;
    Ospfv3InterAreaPrefixLsa *InterAreaPrefixLSAs = nullptr;
    size_t InterAreaPrefixLSAs_arraysize = 0;
    Ospfv3LinkLsa *LinkLSAs = nullptr;
    size_t LinkLSAs_arraysize = 0;
    Ospfv3IntraAreaPrefixLsa *IntraAreaPrefixLSAs = nullptr;
    size_t IntraAreaPrefixLSAs_arraysize = 0;

  private:
    void copy(const Ospfv3LinkStateUpdatePacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv3LinkStateUpdatePacket&);

  public:
    Ospfv3LinkStateUpdatePacket();
    Ospfv3LinkStateUpdatePacket(const Ospfv3LinkStateUpdatePacket& other);
    virtual ~Ospfv3LinkStateUpdatePacket();
    Ospfv3LinkStateUpdatePacket& operator=(const Ospfv3LinkStateUpdatePacket& other);
    virtual Ospfv3LinkStateUpdatePacket *dup() const override {return new Ospfv3LinkStateUpdatePacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getLsaCount() const;
    virtual void setLsaCount(uint32_t lsaCount);
    virtual void setRouterLSAsArraySize(size_t size);
    virtual size_t getRouterLSAsArraySize() const;
    virtual const Ospfv3RouterLsa& getRouterLSAs(size_t k) const;
    virtual Ospfv3RouterLsa& getRouterLSAsForUpdate(size_t k) { handleChange();return const_cast<Ospfv3RouterLsa&>(const_cast<Ospfv3LinkStateUpdatePacket*>(this)->getRouterLSAs(k));}
    virtual void setRouterLSAs(size_t k, const Ospfv3RouterLsa& RouterLSAs);
    virtual void insertRouterLSAs(const Ospfv3RouterLsa& RouterLSAs);
    virtual void insertRouterLSAs(size_t k, const Ospfv3RouterLsa& RouterLSAs);
    virtual void eraseRouterLSAs(size_t k);
    virtual void setNetworkLSAsArraySize(size_t size);
    virtual size_t getNetworkLSAsArraySize() const;
    virtual const Ospfv3NetworkLsa& getNetworkLSAs(size_t k) const;
    virtual Ospfv3NetworkLsa& getNetworkLSAsForUpdate(size_t k) { handleChange();return const_cast<Ospfv3NetworkLsa&>(const_cast<Ospfv3LinkStateUpdatePacket*>(this)->getNetworkLSAs(k));}
    virtual void setNetworkLSAs(size_t k, const Ospfv3NetworkLsa& NetworkLSAs);
    virtual void insertNetworkLSAs(const Ospfv3NetworkLsa& NetworkLSAs);
    virtual void insertNetworkLSAs(size_t k, const Ospfv3NetworkLsa& NetworkLSAs);
    virtual void eraseNetworkLSAs(size_t k);
    virtual void setInterAreaPrefixLSAsArraySize(size_t size);
    virtual size_t getInterAreaPrefixLSAsArraySize() const;
    virtual const Ospfv3InterAreaPrefixLsa& getInterAreaPrefixLSAs(size_t k) const;
    virtual Ospfv3InterAreaPrefixLsa& getInterAreaPrefixLSAsForUpdate(size_t k) { handleChange();return const_cast<Ospfv3InterAreaPrefixLsa&>(const_cast<Ospfv3LinkStateUpdatePacket*>(this)->getInterAreaPrefixLSAs(k));}
    virtual void setInterAreaPrefixLSAs(size_t k, const Ospfv3InterAreaPrefixLsa& InterAreaPrefixLSAs);
    virtual void insertInterAreaPrefixLSAs(const Ospfv3InterAreaPrefixLsa& InterAreaPrefixLSAs);
    virtual void insertInterAreaPrefixLSAs(size_t k, const Ospfv3InterAreaPrefixLsa& InterAreaPrefixLSAs);
    virtual void eraseInterAreaPrefixLSAs(size_t k);
    virtual void setLinkLSAsArraySize(size_t size);
    virtual size_t getLinkLSAsArraySize() const;
    virtual const Ospfv3LinkLsa& getLinkLSAs(size_t k) const;
    virtual Ospfv3LinkLsa& getLinkLSAsForUpdate(size_t k) { handleChange();return const_cast<Ospfv3LinkLsa&>(const_cast<Ospfv3LinkStateUpdatePacket*>(this)->getLinkLSAs(k));}
    virtual void setLinkLSAs(size_t k, const Ospfv3LinkLsa& LinkLSAs);
    virtual void insertLinkLSAs(const Ospfv3LinkLsa& LinkLSAs);
    virtual void insertLinkLSAs(size_t k, const Ospfv3LinkLsa& LinkLSAs);
    virtual void eraseLinkLSAs(size_t k);
    virtual void setIntraAreaPrefixLSAsArraySize(size_t size);
    virtual size_t getIntraAreaPrefixLSAsArraySize() const;
    virtual const Ospfv3IntraAreaPrefixLsa& getIntraAreaPrefixLSAs(size_t k) const;
    virtual Ospfv3IntraAreaPrefixLsa& getIntraAreaPrefixLSAsForUpdate(size_t k) { handleChange();return const_cast<Ospfv3IntraAreaPrefixLsa&>(const_cast<Ospfv3LinkStateUpdatePacket*>(this)->getIntraAreaPrefixLSAs(k));}
    virtual void setIntraAreaPrefixLSAs(size_t k, const Ospfv3IntraAreaPrefixLsa& IntraAreaPrefixLSAs);
    virtual void insertIntraAreaPrefixLSAs(const Ospfv3IntraAreaPrefixLsa& IntraAreaPrefixLSAs);
    virtual void insertIntraAreaPrefixLSAs(size_t k, const Ospfv3IntraAreaPrefixLsa& IntraAreaPrefixLSAs);
    virtual void eraseIntraAreaPrefixLSAs(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv3LinkStateUpdatePacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv3LinkStateUpdatePacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv3/Ospfv3Packet.msg:362</tt> by nedtool.
 * <pre>
 * //Link State Acknowledgement packet
 * class Ospfv3LinkStateAcknowledgementPacket extends Ospfv3Packet
 * {
 *     Ospfv3LsaHeader lsaHeaders[];
 * }
 * </pre>
 */
class INET_API Ospfv3LinkStateAcknowledgementPacket : public ::inet::ospfv3::Ospfv3Packet
{
  protected:
    Ospfv3LsaHeader *lsaHeaders = nullptr;
    size_t lsaHeaders_arraysize = 0;

  private:
    void copy(const Ospfv3LinkStateAcknowledgementPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv3LinkStateAcknowledgementPacket&);

  public:
    Ospfv3LinkStateAcknowledgementPacket();
    Ospfv3LinkStateAcknowledgementPacket(const Ospfv3LinkStateAcknowledgementPacket& other);
    virtual ~Ospfv3LinkStateAcknowledgementPacket();
    Ospfv3LinkStateAcknowledgementPacket& operator=(const Ospfv3LinkStateAcknowledgementPacket& other);
    virtual Ospfv3LinkStateAcknowledgementPacket *dup() const override {return new Ospfv3LinkStateAcknowledgementPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setLsaHeadersArraySize(size_t size);
    virtual size_t getLsaHeadersArraySize() const;
    virtual const Ospfv3LsaHeader& getLsaHeaders(size_t k) const;
    virtual Ospfv3LsaHeader& getLsaHeadersForUpdate(size_t k) { handleChange();return const_cast<Ospfv3LsaHeader&>(const_cast<Ospfv3LinkStateAcknowledgementPacket*>(this)->getLsaHeaders(k));}
    virtual void setLsaHeaders(size_t k, const Ospfv3LsaHeader& lsaHeaders);
    virtual void insertLsaHeaders(const Ospfv3LsaHeader& lsaHeaders);
    virtual void insertLsaHeaders(size_t k, const Ospfv3LsaHeader& lsaHeaders);
    virtual void eraseLsaHeaders(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv3LinkStateAcknowledgementPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv3LinkStateAcknowledgementPacket& obj) {obj.parsimUnpack(b);}

} // namespace ospfv3
} // namespace inet

#endif // ifndef __INET__OSPFV3_OSPFV3PACKET_M_H

