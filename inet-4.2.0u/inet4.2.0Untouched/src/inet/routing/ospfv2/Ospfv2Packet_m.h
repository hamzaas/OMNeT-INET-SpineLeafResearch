//
// Generated file, do not edit! Created by nedtool 5.6 from inet/routing/ospfv2/Ospfv2Packet.msg.
//

#ifndef __INET__OSPFV2_OSPFV2PACKET_M_H
#define __INET__OSPFV2_OSPFV2PACKET_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0506
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// dll export symbol
#ifndef INET_API
#  if defined(INET_EXPORT)
#    define INET_API  OPP_DLLEXPORT
#  elif defined(INET_IMPORT)
#    define INET_API  OPP_DLLIMPORT
#  else
#    define INET_API
#  endif
#endif


namespace inet {
namespace ospfv2 {

struct Ospfv2Options;
class Ospfv2Packet;
class Ospfv2HelloPacket;
class Ospfv2LsaHeader;
class Ospfv2Lsa;
struct Ospfv2TosData;
class Ospfv2Link;
class Ospfv2RouterLsa;
class Ospfv2NetworkLsa;
class Ospfv2SummaryLsa;
struct Ospfv2ExternalTosInfo;
class Ospfv2AsExternalLsaContents;
class Ospfv2AsExternalLsa;
struct Ospfv2DdOptions;
class Ospfv2DatabaseDescriptionPacket;
struct Ospfv2LsaRequest;
class Ospfv2LinkStateRequestPacket;
class Ospfv2LinkStateUpdatePacket;
class Ospfv2LinkStateAcknowledgementPacket;
} // namespace ospfv2
} // namespace inet

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/common/packet/chunk/Chunk_m.h" // import inet.common.packet.chunk.Chunk

#include "inet/networklayer/contract/ipv4/Ipv4Address_m.h" // import inet.networklayer.contract.ipv4.Ipv4Address

#include "inet/routing/ospf_common/OspfPacketBase_m.h" // import inet.routing.ospf_common.OspfPacketBase

#include "inet/transportlayer/common/CrcMode_m.h" // import inet.transportlayer.common.CrcMode


namespace inet {
namespace ospfv2 {

// cplusplus {{
using namespace ospf;
// }}

/**
 * Enum generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:30</tt> by nedtool.
 * <pre>
 * enum Ospfv2TimerType
 * {
 *     INTERFACE_HELLO_TIMER = 0;
 *     INTERFACE_WAIT_TIMER = 1;
 *     INTERFACE_ACKNOWLEDGEMENT_TIMER = 3;
 *     NEIGHBOR_INACTIVITY_TIMER = 4;
 *     NEIGHBOR_POLL_TIMER = 5;
 *     NEIGHBOR_DD_RETRANSMISSION_TIMER = 6;
 *     NEIGHBOR_UPDATE_RETRANSMISSION_TIMER = 7;
 *     NEIGHBOR_REQUEST_RETRANSMISSION_TIMER = 8;
 *     DATABASE_AGE_TIMER = 9;
 * }
 * </pre>
 */
enum Ospfv2TimerType {
    INTERFACE_HELLO_TIMER = 0,
    INTERFACE_WAIT_TIMER = 1,
    INTERFACE_ACKNOWLEDGEMENT_TIMER = 3,
    NEIGHBOR_INACTIVITY_TIMER = 4,
    NEIGHBOR_POLL_TIMER = 5,
    NEIGHBOR_DD_RETRANSMISSION_TIMER = 6,
    NEIGHBOR_UPDATE_RETRANSMISSION_TIMER = 7,
    NEIGHBOR_REQUEST_RETRANSMISSION_TIMER = 8,
    DATABASE_AGE_TIMER = 9
};

/**
 * Struct generated from inet/routing/ospfv2/Ospfv2Packet.msg:44 by nedtool.
 */
struct INET_API Ospfv2Options
{
    Ospfv2Options();
    bool unused_1;
    bool E_ExternalRoutingCapability;
    bool MC_MulticastForwarding;
    bool NP_Type7LSA;
    bool EA_ForwardExternalLSAs;
    bool DC_DemandCircuits;
    bool unused_2;
    bool unused_3;
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const Ospfv2Options& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, Ospfv2Options& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2Options& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2Options& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:59</tt> by nedtool.
 * <pre>
 * //
 * // Represents an OSPF packet header
 * //
 * class Ospfv2Packet extends ospf::OspfPacketBase
 * {
 *     chunkLength = B(24);
 *     version = 2;
 * 
 *     short authenticationType = 0;   // 2 bytes
 *     char authentication[8];         // 8 bytes
 * }
 * </pre>
 */
class INET_API Ospfv2Packet : public ::inet::ospf::OspfPacketBase
{
  protected:
    short authenticationType = 0;
    char authentication[8] = {0};

  private:
    void copy(const Ospfv2Packet& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv2Packet&);

  public:
    Ospfv2Packet();
    Ospfv2Packet(const Ospfv2Packet& other);
    virtual ~Ospfv2Packet();
    Ospfv2Packet& operator=(const Ospfv2Packet& other);
    virtual Ospfv2Packet *dup() const override {return new Ospfv2Packet(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual short getAuthenticationType() const;
    virtual void setAuthenticationType(short authenticationType);
    virtual size_t getAuthenticationArraySize() const;
    virtual char getAuthentication(size_t k) const;
    virtual void setAuthentication(size_t k, char authentication);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2Packet& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2Packet& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:71</tt> by nedtool.
 * <pre>
 * //
 * // Represents an OSPF Hello packet
 * //
 * class Ospfv2HelloPacket extends Ospfv2Packet
 * {
 *     type = HELLO_PACKET;
 *     Ipv4Address networkMask;
 * 
 *     short helloInterval = 5;
 * 
 *     Ospfv2Options options;
 * 
 *     char routerPriority = 0;
 *     long routerDeadInterval = 0;
 * 
 *     Ipv4Address designatedRouter;
 *     Ipv4Address backupDesignatedRouter;
 *     Ipv4Address neighbor[];
 * }
 * </pre>
 */
class INET_API Ospfv2HelloPacket : public ::inet::ospfv2::Ospfv2Packet
{
  protected:
    Ipv4Address networkMask;
    short helloInterval = 5;
    Ospfv2Options options;
    char routerPriority = 0;
    long routerDeadInterval = 0;
    Ipv4Address designatedRouter;
    Ipv4Address backupDesignatedRouter;
    Ipv4Address *neighbor = nullptr;
    size_t neighbor_arraysize = 0;

  private:
    void copy(const Ospfv2HelloPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv2HelloPacket&);

  public:
    Ospfv2HelloPacket();
    Ospfv2HelloPacket(const Ospfv2HelloPacket& other);
    virtual ~Ospfv2HelloPacket();
    Ospfv2HelloPacket& operator=(const Ospfv2HelloPacket& other);
    virtual Ospfv2HelloPacket *dup() const override {return new Ospfv2HelloPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ipv4Address& getNetworkMask() const;
    virtual Ipv4Address& getNetworkMaskForUpdate() { handleChange();return const_cast<Ipv4Address&>(const_cast<Ospfv2HelloPacket*>(this)->getNetworkMask());}
    virtual void setNetworkMask(const Ipv4Address& networkMask);
    virtual short getHelloInterval() const;
    virtual void setHelloInterval(short helloInterval);
    virtual const Ospfv2Options& getOptions() const;
    virtual Ospfv2Options& getOptionsForUpdate() { handleChange();return const_cast<Ospfv2Options&>(const_cast<Ospfv2HelloPacket*>(this)->getOptions());}
    virtual void setOptions(const Ospfv2Options& options);
    virtual char getRouterPriority() const;
    virtual void setRouterPriority(char routerPriority);
    virtual long getRouterDeadInterval() const;
    virtual void setRouterDeadInterval(long routerDeadInterval);
    virtual const Ipv4Address& getDesignatedRouter() const;
    virtual Ipv4Address& getDesignatedRouterForUpdate() { handleChange();return const_cast<Ipv4Address&>(const_cast<Ospfv2HelloPacket*>(this)->getDesignatedRouter());}
    virtual void setDesignatedRouter(const Ipv4Address& designatedRouter);
    virtual const Ipv4Address& getBackupDesignatedRouter() const;
    virtual Ipv4Address& getBackupDesignatedRouterForUpdate() { handleChange();return const_cast<Ipv4Address&>(const_cast<Ospfv2HelloPacket*>(this)->getBackupDesignatedRouter());}
    virtual void setBackupDesignatedRouter(const Ipv4Address& backupDesignatedRouter);
    virtual void setNeighborArraySize(size_t size);
    virtual size_t getNeighborArraySize() const;
    virtual const Ipv4Address& getNeighbor(size_t k) const;
    virtual Ipv4Address& getNeighborForUpdate(size_t k) { handleChange();return const_cast<Ipv4Address&>(const_cast<Ospfv2HelloPacket*>(this)->getNeighbor(k));}
    virtual void setNeighbor(size_t k, const Ipv4Address& neighbor);
    virtual void insertNeighbor(const Ipv4Address& neighbor);
    virtual void insertNeighbor(size_t k, const Ipv4Address& neighbor);
    virtual void eraseNeighbor(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2HelloPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2HelloPacket& obj) {obj.parsimUnpack(b);}

/**
 * Enum generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:89</tt> by nedtool.
 * <pre>
 * enum Ospfv2LsaType
 * {
 *     ROUTERLSA_TYPE = 1;
 *     NETWORKLSA_TYPE = 2;
 *     SUMMARYLSA_NETWORKS_TYPE = 3;
 *     SUMMARYLSA_ASBOUNDARYROUTERS_TYPE = 4;
 *     AS_EXTERNAL_LSA_TYPE = 5;
 * }
 * </pre>
 */
enum Ospfv2LsaType {
    ROUTERLSA_TYPE = 1,
    NETWORKLSA_TYPE = 2,
    SUMMARYLSA_NETWORKS_TYPE = 3,
    SUMMARYLSA_ASBOUNDARYROUTERS_TYPE = 4,
    AS_EXTERNAL_LSA_TYPE = 5
};

/**
 * Class generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:101</tt> by nedtool.
 * <pre>
 * //
 * // Represents an OSPF LSA header
 * //
 * class Ospfv2LsaHeader extends cObject
 * {
 *     unsigned short lsAge = 0;
 *     Ospfv2Options lsOptions;
 *     Ospfv2LsaType lsType = static_cast<Ospfv2LsaType>(-1);
 *     Ipv4Address linkStateID;
 *     Ipv4Address advertisingRouter;
 *     int32_t lsSequenceNumber = 0;
 *     uint16_t lsCrc = 0;
 *     CrcMode lsCrcMode = CRC_MODE_UNDEFINED;
 *     uint16_t lsaLength = 0;
 * }
 * </pre>
 */
class INET_API Ospfv2LsaHeader : public ::omnetpp::cObject
{
  protected:
    unsigned short lsAge = 0;
    Ospfv2Options lsOptions;
    inet::ospfv2::Ospfv2LsaType lsType = static_cast<Ospfv2LsaType>(-1);
    Ipv4Address linkStateID;
    Ipv4Address advertisingRouter;
    int32_t lsSequenceNumber = 0;
    uint16_t lsCrc = 0;
    inet::CrcMode lsCrcMode = CRC_MODE_UNDEFINED;
    uint16_t lsaLength = 0;

  private:
    void copy(const Ospfv2LsaHeader& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv2LsaHeader&);

  public:
    Ospfv2LsaHeader();
    Ospfv2LsaHeader(const Ospfv2LsaHeader& other);
    virtual ~Ospfv2LsaHeader();
    Ospfv2LsaHeader& operator=(const Ospfv2LsaHeader& other);
    virtual Ospfv2LsaHeader *dup() const override {return new Ospfv2LsaHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned short getLsAge() const;
    virtual void setLsAge(unsigned short lsAge);
    virtual const Ospfv2Options& getLsOptions() const;
    virtual Ospfv2Options& getLsOptionsForUpdate() { return const_cast<Ospfv2Options&>(const_cast<Ospfv2LsaHeader*>(this)->getLsOptions());}
    virtual void setLsOptions(const Ospfv2Options& lsOptions);
    virtual inet::ospfv2::Ospfv2LsaType getLsType() const;
    virtual void setLsType(inet::ospfv2::Ospfv2LsaType lsType);
    virtual const Ipv4Address& getLinkStateID() const;
    virtual Ipv4Address& getLinkStateIDForUpdate() { return const_cast<Ipv4Address&>(const_cast<Ospfv2LsaHeader*>(this)->getLinkStateID());}
    virtual void setLinkStateID(const Ipv4Address& linkStateID);
    virtual const Ipv4Address& getAdvertisingRouter() const;
    virtual Ipv4Address& getAdvertisingRouterForUpdate() { return const_cast<Ipv4Address&>(const_cast<Ospfv2LsaHeader*>(this)->getAdvertisingRouter());}
    virtual void setAdvertisingRouter(const Ipv4Address& advertisingRouter);
    virtual int32_t getLsSequenceNumber() const;
    virtual void setLsSequenceNumber(int32_t lsSequenceNumber);
    virtual uint16_t getLsCrc() const;
    virtual void setLsCrc(uint16_t lsCrc);
    virtual inet::CrcMode getLsCrcMode() const;
    virtual void setLsCrcMode(inet::CrcMode lsCrcMode);
    virtual uint16_t getLsaLength() const;
    virtual void setLsaLength(uint16_t lsaLength);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2LsaHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2LsaHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:117</tt> by nedtool.
 * <pre>
 * //
 * // common ancestor type for all LSAs
 * //
 * class Ospfv2Lsa extends cObject
 * {
 *     Ospfv2LsaHeader header;
 * }
 * </pre>
 */
class INET_API Ospfv2Lsa : public ::omnetpp::cObject
{
  protected:
    Ospfv2LsaHeader header;

  private:
    void copy(const Ospfv2Lsa& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv2Lsa&);

  public:
    Ospfv2Lsa();
    Ospfv2Lsa(const Ospfv2Lsa& other);
    virtual ~Ospfv2Lsa();
    Ospfv2Lsa& operator=(const Ospfv2Lsa& other);
    virtual Ospfv2Lsa *dup() const override {return new Ospfv2Lsa(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ospfv2LsaHeader& getHeader() const;
    virtual Ospfv2LsaHeader& getHeaderForUpdate() { return const_cast<Ospfv2LsaHeader&>(const_cast<Ospfv2Lsa*>(this)->getHeader());}
    virtual void setHeader(const Ospfv2LsaHeader& header);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2Lsa& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2Lsa& obj) {obj.parsimUnpack(b);}

/**
 * Enum generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:122</tt> by nedtool.
 * <pre>
 * enum LinkType
 * {
 *     POINTTOPOINT_LINK = 1;
 *     TRANSIT_LINK = 2;
 *     STUB_LINK = 3;
 *     VIRTUAL_LINK = 4;
 * }
 * </pre>
 */
enum LinkType {
    POINTTOPOINT_LINK = 1,
    TRANSIT_LINK = 2,
    STUB_LINK = 3,
    VIRTUAL_LINK = 4
};

/**
 * Struct generated from inet/routing/ospfv2/Ospfv2Packet.msg:131 by nedtool.
 */
struct INET_API Ospfv2TosData
{
    Ospfv2TosData();
    unsigned char tos;
    unsigned long tosMetric;
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const Ospfv2TosData& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, Ospfv2TosData& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2TosData& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2TosData& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:138</tt> by nedtool.
 * <pre>
 * // Router LSA Link section (RFC 1583 Section A.4.2.)
 * class Ospfv2Link extends cObject
 * {
 *     Ipv4Address linkID;
 *     unsigned long linkData = 0;
 *     LinkType type = POINTTOPOINT_LINK;
 *     unsigned char numberOfTOS = 0;
 *     unsigned long linkCost = 1;     // TOS 0 metric
 *     Ospfv2TosData tosData[];
 * }
 * </pre>
 */
class INET_API Ospfv2Link : public ::omnetpp::cObject
{
  protected:
    Ipv4Address linkID;
    unsigned long linkData = 0;
    inet::ospfv2::LinkType type = POINTTOPOINT_LINK;
    unsigned char numberOfTOS = 0;
    unsigned long linkCost = 1;
    Ospfv2TosData *tosData = nullptr;
    size_t tosData_arraysize = 0;

  private:
    void copy(const Ospfv2Link& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv2Link&);

  public:
    Ospfv2Link();
    Ospfv2Link(const Ospfv2Link& other);
    virtual ~Ospfv2Link();
    Ospfv2Link& operator=(const Ospfv2Link& other);
    virtual Ospfv2Link *dup() const override {return new Ospfv2Link(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ipv4Address& getLinkID() const;
    virtual Ipv4Address& getLinkIDForUpdate() { return const_cast<Ipv4Address&>(const_cast<Ospfv2Link*>(this)->getLinkID());}
    virtual void setLinkID(const Ipv4Address& linkID);
    virtual unsigned long getLinkData() const;
    virtual void setLinkData(unsigned long linkData);
    virtual inet::ospfv2::LinkType getType() const;
    virtual void setType(inet::ospfv2::LinkType type);
    virtual unsigned char getNumberOfTOS() const;
    virtual void setNumberOfTOS(unsigned char numberOfTOS);
    virtual unsigned long getLinkCost() const;
    virtual void setLinkCost(unsigned long linkCost);
    virtual void setTosDataArraySize(size_t size);
    virtual size_t getTosDataArraySize() const;
    virtual const Ospfv2TosData& getTosData(size_t k) const;
    virtual Ospfv2TosData& getTosDataForUpdate(size_t k) { return const_cast<Ospfv2TosData&>(const_cast<Ospfv2Link*>(this)->getTosData(k));}
    virtual void setTosData(size_t k, const Ospfv2TosData& tosData);
    virtual void insertTosData(const Ospfv2TosData& tosData);
    virtual void insertTosData(size_t k, const Ospfv2TosData& tosData);
    virtual void eraseTosData(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2Link& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2Link& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:151</tt> by nedtool.
 * <pre>
 * //
 * // Represents an OSPF Router LSA (RFC 1583 Section A.4.2.)
 * //
 * class Ospfv2RouterLsa extends Ospfv2Lsa
 * {
 *     // header.lsType = ROUTERLSA_TYPE;
 *     unsigned short reserved1 = 0;   // 5 bit
 *     bool V_VirtualLinkEndpoint = false;
 *     bool E_ASBoundaryRouter = false;
 *     bool B_AreaBorderRouter = false;
 *     unsigned short reserved2 = 0;   // 8 bit
 *     unsigned short numberOfLinks = 0;
 *     Ospfv2Link links[];
 * }
 * </pre>
 */
class INET_API Ospfv2RouterLsa : public ::inet::ospfv2::Ospfv2Lsa
{
  protected:
    unsigned short reserved1 = 0;
    bool V_VirtualLinkEndpoint = false;
    bool E_ASBoundaryRouter = false;
    bool B_AreaBorderRouter = false;
    unsigned short reserved2 = 0;
    unsigned short numberOfLinks = 0;
    Ospfv2Link *links = nullptr;
    size_t links_arraysize = 0;

  private:
    void copy(const Ospfv2RouterLsa& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv2RouterLsa&);

  public:
    Ospfv2RouterLsa();
    Ospfv2RouterLsa(const Ospfv2RouterLsa& other);
    virtual ~Ospfv2RouterLsa();
    Ospfv2RouterLsa& operator=(const Ospfv2RouterLsa& other);
    virtual Ospfv2RouterLsa *dup() const override {return new Ospfv2RouterLsa(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned short getReserved1() const;
    virtual void setReserved1(unsigned short reserved1);
    virtual bool getV_VirtualLinkEndpoint() const;
    virtual void setV_VirtualLinkEndpoint(bool V_VirtualLinkEndpoint);
    virtual bool getE_ASBoundaryRouter() const;
    virtual void setE_ASBoundaryRouter(bool E_ASBoundaryRouter);
    virtual bool getB_AreaBorderRouter() const;
    virtual void setB_AreaBorderRouter(bool B_AreaBorderRouter);
    virtual unsigned short getReserved2() const;
    virtual void setReserved2(unsigned short reserved2);
    virtual unsigned short getNumberOfLinks() const;
    virtual void setNumberOfLinks(unsigned short numberOfLinks);
    virtual void setLinksArraySize(size_t size);
    virtual size_t getLinksArraySize() const;
    virtual const Ospfv2Link& getLinks(size_t k) const;
    virtual Ospfv2Link& getLinksForUpdate(size_t k) { return const_cast<Ospfv2Link&>(const_cast<Ospfv2RouterLsa*>(this)->getLinks(k));}
    virtual void setLinks(size_t k, const Ospfv2Link& links);
    virtual void insertLinks(const Ospfv2Link& links);
    virtual void insertLinks(size_t k, const Ospfv2Link& links);
    virtual void eraseLinks(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2RouterLsa& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2RouterLsa& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:166</tt> by nedtool.
 * <pre>
 * //
 * // Represents an OSPF Network LSA
 * //
 * class Ospfv2NetworkLsa extends Ospfv2Lsa
 * {
 *     // header.lsType = NETWORKLSA_TYPE;
 *     Ipv4Address networkMask;
 *     Ipv4Address attachedRouters[];
 * }
 * </pre>
 */
class INET_API Ospfv2NetworkLsa : public ::inet::ospfv2::Ospfv2Lsa
{
  protected:
    Ipv4Address networkMask;
    Ipv4Address *attachedRouters = nullptr;
    size_t attachedRouters_arraysize = 0;

  private:
    void copy(const Ospfv2NetworkLsa& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv2NetworkLsa&);

  public:
    Ospfv2NetworkLsa();
    Ospfv2NetworkLsa(const Ospfv2NetworkLsa& other);
    virtual ~Ospfv2NetworkLsa();
    Ospfv2NetworkLsa& operator=(const Ospfv2NetworkLsa& other);
    virtual Ospfv2NetworkLsa *dup() const override {return new Ospfv2NetworkLsa(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ipv4Address& getNetworkMask() const;
    virtual Ipv4Address& getNetworkMaskForUpdate() { return const_cast<Ipv4Address&>(const_cast<Ospfv2NetworkLsa*>(this)->getNetworkMask());}
    virtual void setNetworkMask(const Ipv4Address& networkMask);
    virtual void setAttachedRoutersArraySize(size_t size);
    virtual size_t getAttachedRoutersArraySize() const;
    virtual const Ipv4Address& getAttachedRouters(size_t k) const;
    virtual Ipv4Address& getAttachedRoutersForUpdate(size_t k) { return const_cast<Ipv4Address&>(const_cast<Ospfv2NetworkLsa*>(this)->getAttachedRouters(k));}
    virtual void setAttachedRouters(size_t k, const Ipv4Address& attachedRouters);
    virtual void insertAttachedRouters(const Ipv4Address& attachedRouters);
    virtual void insertAttachedRouters(size_t k, const Ipv4Address& attachedRouters);
    virtual void eraseAttachedRouters(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2NetworkLsa& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2NetworkLsa& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:176</tt> by nedtool.
 * <pre>
 * //
 * // Represents an OSPF Summary LSA
 * //
 * class Ospfv2SummaryLsa extends Ospfv2Lsa
 * {
 *     // header.lsType = SUMMARYLSA_NETWORKS_TYPE;
 *     Ipv4Address networkMask;
 *     unsigned long routeCost = 1;
 *     Ospfv2TosData tosData[];  // 1 element required, count of tosData not stored, calculate it from length of LSA
 * }
 * </pre>
 */
class INET_API Ospfv2SummaryLsa : public ::inet::ospfv2::Ospfv2Lsa
{
  protected:
    Ipv4Address networkMask;
    unsigned long routeCost = 1;
    Ospfv2TosData *tosData = nullptr;
    size_t tosData_arraysize = 0;

  private:
    void copy(const Ospfv2SummaryLsa& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv2SummaryLsa&);

  public:
    Ospfv2SummaryLsa();
    Ospfv2SummaryLsa(const Ospfv2SummaryLsa& other);
    virtual ~Ospfv2SummaryLsa();
    Ospfv2SummaryLsa& operator=(const Ospfv2SummaryLsa& other);
    virtual Ospfv2SummaryLsa *dup() const override {return new Ospfv2SummaryLsa(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ipv4Address& getNetworkMask() const;
    virtual Ipv4Address& getNetworkMaskForUpdate() { return const_cast<Ipv4Address&>(const_cast<Ospfv2SummaryLsa*>(this)->getNetworkMask());}
    virtual void setNetworkMask(const Ipv4Address& networkMask);
    virtual unsigned long getRouteCost() const;
    virtual void setRouteCost(unsigned long routeCost);
    virtual void setTosDataArraySize(size_t size);
    virtual size_t getTosDataArraySize() const;
    virtual const Ospfv2TosData& getTosData(size_t k) const;
    virtual Ospfv2TosData& getTosDataForUpdate(size_t k) { return const_cast<Ospfv2TosData&>(const_cast<Ospfv2SummaryLsa*>(this)->getTosData(k));}
    virtual void setTosData(size_t k, const Ospfv2TosData& tosData);
    virtual void insertTosData(const Ospfv2TosData& tosData);
    virtual void insertTosData(size_t k, const Ospfv2TosData& tosData);
    virtual void eraseTosData(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2SummaryLsa& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2SummaryLsa& obj) {obj.parsimUnpack(b);}

/**
 * Struct generated from inet/routing/ospfv2/Ospfv2Packet.msg:184 by nedtool.
 */
struct INET_API Ospfv2ExternalTosInfo
{
    Ospfv2ExternalTosInfo();
    unsigned short tos;
    bool E_ExternalMetricType;
    unsigned long routeCost;
    Ipv4Address forwardingAddress;
    long externalRouteTag;
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const Ospfv2ExternalTosInfo& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, Ospfv2ExternalTosInfo& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2ExternalTosInfo& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2ExternalTosInfo& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:197</tt> by nedtool.
 * <pre>
 * //
 * // Represents the contents of an OSPF AS External LSA
 * //
 * class Ospfv2AsExternalLsaContents extends cObject
 * {
 *     Ipv4Address networkMask;
 *     Ospfv2ExternalTosInfo externalTOSInfo[];
 * }
 * </pre>
 */
class INET_API Ospfv2AsExternalLsaContents : public ::omnetpp::cObject
{
  protected:
    Ipv4Address networkMask;
    Ospfv2ExternalTosInfo *externalTOSInfo = nullptr;
    size_t externalTOSInfo_arraysize = 0;

  private:
    void copy(const Ospfv2AsExternalLsaContents& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv2AsExternalLsaContents&);

  public:
    Ospfv2AsExternalLsaContents();
    Ospfv2AsExternalLsaContents(const Ospfv2AsExternalLsaContents& other);
    virtual ~Ospfv2AsExternalLsaContents();
    Ospfv2AsExternalLsaContents& operator=(const Ospfv2AsExternalLsaContents& other);
    virtual Ospfv2AsExternalLsaContents *dup() const override {return new Ospfv2AsExternalLsaContents(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ipv4Address& getNetworkMask() const;
    virtual Ipv4Address& getNetworkMaskForUpdate() { return const_cast<Ipv4Address&>(const_cast<Ospfv2AsExternalLsaContents*>(this)->getNetworkMask());}
    virtual void setNetworkMask(const Ipv4Address& networkMask);
    virtual void setExternalTOSInfoArraySize(size_t size);
    virtual size_t getExternalTOSInfoArraySize() const;
    virtual const Ospfv2ExternalTosInfo& getExternalTOSInfo(size_t k) const;
    virtual Ospfv2ExternalTosInfo& getExternalTOSInfoForUpdate(size_t k) { return const_cast<Ospfv2ExternalTosInfo&>(const_cast<Ospfv2AsExternalLsaContents*>(this)->getExternalTOSInfo(k));}
    virtual void setExternalTOSInfo(size_t k, const Ospfv2ExternalTosInfo& externalTOSInfo);
    virtual void insertExternalTOSInfo(const Ospfv2ExternalTosInfo& externalTOSInfo);
    virtual void insertExternalTOSInfo(size_t k, const Ospfv2ExternalTosInfo& externalTOSInfo);
    virtual void eraseExternalTOSInfo(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2AsExternalLsaContents& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2AsExternalLsaContents& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:206</tt> by nedtool.
 * <pre>
 * //
 * // Represents an OSPF AS External LSA
 * //
 * class Ospfv2AsExternalLsa extends Ospfv2Lsa
 * {
 *     // header.lsType = AS_EXTERNAL_LSA_TYPE;
 *     Ospfv2AsExternalLsaContents contents;
 * }
 * </pre>
 */
class INET_API Ospfv2AsExternalLsa : public ::inet::ospfv2::Ospfv2Lsa
{
  protected:
    Ospfv2AsExternalLsaContents contents;

  private:
    void copy(const Ospfv2AsExternalLsa& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv2AsExternalLsa&);

  public:
    Ospfv2AsExternalLsa();
    Ospfv2AsExternalLsa(const Ospfv2AsExternalLsa& other);
    virtual ~Ospfv2AsExternalLsa();
    Ospfv2AsExternalLsa& operator=(const Ospfv2AsExternalLsa& other);
    virtual Ospfv2AsExternalLsa *dup() const override {return new Ospfv2AsExternalLsa(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ospfv2AsExternalLsaContents& getContents() const;
    virtual Ospfv2AsExternalLsaContents& getContentsForUpdate() { return const_cast<Ospfv2AsExternalLsaContents&>(const_cast<Ospfv2AsExternalLsa*>(this)->getContents());}
    virtual void setContents(const Ospfv2AsExternalLsaContents& contents);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2AsExternalLsa& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2AsExternalLsa& obj) {obj.parsimUnpack(b);}

/**
 * Struct generated from inet/routing/ospfv2/Ospfv2Packet.msg:214 by nedtool.
 */
struct INET_API Ospfv2DdOptions
{
    Ospfv2DdOptions();
    unsigned short unused;
    bool I_Init;
    bool M_More;
    bool MS_MasterSlave;
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const Ospfv2DdOptions& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, Ospfv2DdOptions& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2DdOptions& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2DdOptions& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:225</tt> by nedtool.
 * <pre>
 * //
 * // Represents an OSPF Database Description packet
 * //
 * class Ospfv2DatabaseDescriptionPacket extends Ospfv2Packet
 * {
 *     unsigned short interfaceMTU;
 *     Ospfv2Options options;
 *     Ospfv2DdOptions ddOptions;
 *     unsigned long ddSequenceNumber;
 *     Ospfv2LsaHeader lsaHeaders[];     //TODO
 * }
 * </pre>
 */
class INET_API Ospfv2DatabaseDescriptionPacket : public ::inet::ospfv2::Ospfv2Packet
{
  protected:
    unsigned short interfaceMTU = 0;
    Ospfv2Options options;
    Ospfv2DdOptions ddOptions;
    unsigned long ddSequenceNumber = 0;
    Ospfv2LsaHeader *lsaHeaders = nullptr;
    size_t lsaHeaders_arraysize = 0;

  private:
    void copy(const Ospfv2DatabaseDescriptionPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv2DatabaseDescriptionPacket&);

  public:
    Ospfv2DatabaseDescriptionPacket();
    Ospfv2DatabaseDescriptionPacket(const Ospfv2DatabaseDescriptionPacket& other);
    virtual ~Ospfv2DatabaseDescriptionPacket();
    Ospfv2DatabaseDescriptionPacket& operator=(const Ospfv2DatabaseDescriptionPacket& other);
    virtual Ospfv2DatabaseDescriptionPacket *dup() const override {return new Ospfv2DatabaseDescriptionPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned short getInterfaceMTU() const;
    virtual void setInterfaceMTU(unsigned short interfaceMTU);
    virtual const Ospfv2Options& getOptions() const;
    virtual Ospfv2Options& getOptionsForUpdate() { handleChange();return const_cast<Ospfv2Options&>(const_cast<Ospfv2DatabaseDescriptionPacket*>(this)->getOptions());}
    virtual void setOptions(const Ospfv2Options& options);
    virtual const Ospfv2DdOptions& getDdOptions() const;
    virtual Ospfv2DdOptions& getDdOptionsForUpdate() { handleChange();return const_cast<Ospfv2DdOptions&>(const_cast<Ospfv2DatabaseDescriptionPacket*>(this)->getDdOptions());}
    virtual void setDdOptions(const Ospfv2DdOptions& ddOptions);
    virtual unsigned long getDdSequenceNumber() const;
    virtual void setDdSequenceNumber(unsigned long ddSequenceNumber);
    virtual void setLsaHeadersArraySize(size_t size);
    virtual size_t getLsaHeadersArraySize() const;
    virtual const Ospfv2LsaHeader& getLsaHeaders(size_t k) const;
    virtual Ospfv2LsaHeader& getLsaHeadersForUpdate(size_t k) { handleChange();return const_cast<Ospfv2LsaHeader&>(const_cast<Ospfv2DatabaseDescriptionPacket*>(this)->getLsaHeaders(k));}
    virtual void setLsaHeaders(size_t k, const Ospfv2LsaHeader& lsaHeaders);
    virtual void insertLsaHeaders(const Ospfv2LsaHeader& lsaHeaders);
    virtual void insertLsaHeaders(size_t k, const Ospfv2LsaHeader& lsaHeaders);
    virtual void eraseLsaHeaders(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2DatabaseDescriptionPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2DatabaseDescriptionPacket& obj) {obj.parsimUnpack(b);}

/**
 * Struct generated from inet/routing/ospfv2/Ospfv2Packet.msg:234 by nedtool.
 */
struct INET_API Ospfv2LsaRequest
{
    Ospfv2LsaRequest();
    unsigned long lsType;
    Ipv4Address linkStateID;
    Ipv4Address advertisingRouter;
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const Ospfv2LsaRequest& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, Ospfv2LsaRequest& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2LsaRequest& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2LsaRequest& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:244</tt> by nedtool.
 * <pre>
 * //
 * // Represents an OSPF Link State Request packet
 * //
 * class Ospfv2LinkStateRequestPacket extends Ospfv2Packet
 * {
 *     Ospfv2LsaRequest requests[];
 * }
 * </pre>
 */
class INET_API Ospfv2LinkStateRequestPacket : public ::inet::ospfv2::Ospfv2Packet
{
  protected:
    Ospfv2LsaRequest *requests = nullptr;
    size_t requests_arraysize = 0;

  private:
    void copy(const Ospfv2LinkStateRequestPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv2LinkStateRequestPacket&);

  public:
    Ospfv2LinkStateRequestPacket();
    Ospfv2LinkStateRequestPacket(const Ospfv2LinkStateRequestPacket& other);
    virtual ~Ospfv2LinkStateRequestPacket();
    Ospfv2LinkStateRequestPacket& operator=(const Ospfv2LinkStateRequestPacket& other);
    virtual Ospfv2LinkStateRequestPacket *dup() const override {return new Ospfv2LinkStateRequestPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setRequestsArraySize(size_t size);
    virtual size_t getRequestsArraySize() const;
    virtual const Ospfv2LsaRequest& getRequests(size_t k) const;
    virtual Ospfv2LsaRequest& getRequestsForUpdate(size_t k) { handleChange();return const_cast<Ospfv2LsaRequest&>(const_cast<Ospfv2LinkStateRequestPacket*>(this)->getRequests(k));}
    virtual void setRequests(size_t k, const Ospfv2LsaRequest& requests);
    virtual void insertRequests(const Ospfv2LsaRequest& requests);
    virtual void insertRequests(size_t k, const Ospfv2LsaRequest& requests);
    virtual void eraseRequests(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2LinkStateRequestPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2LinkStateRequestPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:252</tt> by nedtool.
 * <pre>
 * //
 * // Represents an OSPF Link State Update packet
 * //
 * class Ospfv2LinkStateUpdatePacket extends Ospfv2Packet
 * {
 *     Ospfv2Lsa *ospfLSAs[] \@owned \@allowReplace;
 * }
 * </pre>
 */
class INET_API Ospfv2LinkStateUpdatePacket : public ::inet::ospfv2::Ospfv2Packet
{
  protected:
    Ospfv2Lsa * *ospfLSAs = nullptr;
    size_t ospfLSAs_arraysize = 0;

  private:
    void copy(const Ospfv2LinkStateUpdatePacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv2LinkStateUpdatePacket&);

  public:
    Ospfv2LinkStateUpdatePacket();
    Ospfv2LinkStateUpdatePacket(const Ospfv2LinkStateUpdatePacket& other);
    virtual ~Ospfv2LinkStateUpdatePacket();
    Ospfv2LinkStateUpdatePacket& operator=(const Ospfv2LinkStateUpdatePacket& other);
    virtual Ospfv2LinkStateUpdatePacket *dup() const override {return new Ospfv2LinkStateUpdatePacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setOspfLSAsArraySize(size_t size);
    virtual size_t getOspfLSAsArraySize() const;
    virtual const Ospfv2Lsa * getOspfLSAs(size_t k) const;
    virtual Ospfv2Lsa * getOspfLSAsForUpdate(size_t k) { handleChange();return const_cast<Ospfv2Lsa *>(const_cast<Ospfv2LinkStateUpdatePacket*>(this)->getOspfLSAs(k));}
    virtual Ospfv2Lsa * dropOspfLSAs(size_t k);
    virtual void setOspfLSAs(size_t k, Ospfv2Lsa * ospfLSAs);
    virtual void insertOspfLSAs(Ospfv2Lsa * ospfLSAs);
    virtual void insertOspfLSAs(size_t k, Ospfv2Lsa * ospfLSAs);
    virtual void eraseOspfLSAs(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2LinkStateUpdatePacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2LinkStateUpdatePacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:260</tt> by nedtool.
 * <pre>
 * //
 * // Represents an OSPF Link State Acknowledgement packet
 * //
 * class Ospfv2LinkStateAcknowledgementPacket extends Ospfv2Packet
 * {
 *     Ospfv2LsaHeader lsaHeaders[];     //TODO
 * }
 * </pre>
 */
class INET_API Ospfv2LinkStateAcknowledgementPacket : public ::inet::ospfv2::Ospfv2Packet
{
  protected:
    Ospfv2LsaHeader *lsaHeaders = nullptr;
    size_t lsaHeaders_arraysize = 0;

  private:
    void copy(const Ospfv2LinkStateAcknowledgementPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ospfv2LinkStateAcknowledgementPacket&);

  public:
    Ospfv2LinkStateAcknowledgementPacket();
    Ospfv2LinkStateAcknowledgementPacket(const Ospfv2LinkStateAcknowledgementPacket& other);
    virtual ~Ospfv2LinkStateAcknowledgementPacket();
    Ospfv2LinkStateAcknowledgementPacket& operator=(const Ospfv2LinkStateAcknowledgementPacket& other);
    virtual Ospfv2LinkStateAcknowledgementPacket *dup() const override {return new Ospfv2LinkStateAcknowledgementPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setLsaHeadersArraySize(size_t size);
    virtual size_t getLsaHeadersArraySize() const;
    virtual const Ospfv2LsaHeader& getLsaHeaders(size_t k) const;
    virtual Ospfv2LsaHeader& getLsaHeadersForUpdate(size_t k) { handleChange();return const_cast<Ospfv2LsaHeader&>(const_cast<Ospfv2LinkStateAcknowledgementPacket*>(this)->getLsaHeaders(k));}
    virtual void setLsaHeaders(size_t k, const Ospfv2LsaHeader& lsaHeaders);
    virtual void insertLsaHeaders(const Ospfv2LsaHeader& lsaHeaders);
    virtual void insertLsaHeaders(size_t k, const Ospfv2LsaHeader& lsaHeaders);
    virtual void eraseLsaHeaders(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2LinkStateAcknowledgementPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2LinkStateAcknowledgementPacket& obj) {obj.parsimUnpack(b);}

} // namespace ospfv2
} // namespace inet

#endif // ifndef __INET__OSPFV2_OSPFV2PACKET_M_H

